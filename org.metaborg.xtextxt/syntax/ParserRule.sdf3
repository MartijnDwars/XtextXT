module ParserRule

imports
  
  Common
  
context-free syntax
  
  Rule.ParserRule = ID Returns /* HiddenToken? */ ":"
    Alternatives
  ";"
  
  Returns.None       =
  Returns.Returns    = "returns" TypeRef
  
  TypeRef.MetaModel  = ID '::' ID
  TypeRef.Classifier = ID
  
  // 
  // HiddenToken.HiddenToken = "hidden" "(" {RuleCall ","}+ ")"
  // 
  Alternatives.Alternatives = {Group "|"}+ // Group used to be UnorderedGroup
  // 
  // UnorderedGroup.UnorderedGroup = {Group "&"}+
  // 
  Group.Group = Token+
  
  // Token.Assignment = /* Predicated? */ ID Operator AssignableTerminal Cardinality?
  Token.Optional = Terminal "?"
  Token.Multiple = Terminal "+"
  Token.Any      = Terminal "*"
  Token          = Terminal
  // Token.Action  = Action
  // 
  // Operator.Assignment        = "="
  // Operator.AddAssignment     = "+="
  // Operator.BooleanAssignment = "?="
  // 
  // Predicated.Predicated         = "=>"
  // Predicated.FirstSetPredicated = "->"
  // 
  // AssignableTerminal.Keyword = STRING
  // AssignableTerminal = RuleCall
  // // {bracket} is added because without it, the constructor will not be available 
  // AssignableTerminal = <( <AssignableAlternatives> )> {bracket}
  // AssignableTerminal.CrossReference = <[ <TypeRef> <CrossReferenceableTerminal?> ]> 
  // 
  // CrossReferenceableTerminal.CrossReferenceableTerminal = <| <RuleCall>>
  // 
  // RuleCall.RuleCall = ID
  // 
  // AssignableAlternatives.AssignableAlternatives = {AssignableTerminal "|"}+
  // 
  // Action.Action = <{ <TypeRef> <ActionCurrent?> }>
  // ActionCurrent.ActionCurrent = <. <ID> <Operator> current>
  // 
  Terminal.Keyword = STRING
  // Terminal = <( <Alternatives> )>
  // Terminal.Call = RuleCall
  // Terminal.PredicatedKeyword = Predicated STRING
  // Terminal.PredicatedRuleCall = Predicated RuleCall
  // Terminal.PredicatedGroup = <<Predicated> ( <Alternatives> )>
